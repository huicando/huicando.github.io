<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer 02]]></title>
    <url>%2F2020%2F01%2F14%2F%E5%89%91%E6%8C%87offer%2002%2F</url>
    <content type="text"><![CDATA[剑指offer 0225.和为S的连续正数序列 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 1输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 我的思路12345678910111213141516171819202122232425public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(sum&lt;=2)&#123; return lists; &#125; int sum1 =0; int count=2; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i=1;i&lt;=sum/2+1;i++)&#123; sum1+=i; if(sum1&lt;sum)&#123; list.add(i); &#125;else if(sum1==sum)&#123; list.add(i); lists.add(list); &#125;else &#123; sum1=0; list=new ArrayList&lt;Integer&gt;(); i=count-1; count++; &#125; &#125; return lists; &#125; 双指针思路123456789101112131415161718192021public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); int left=1,right=2; while(left&lt;right)&#123; int count = (right+left)*(right-left+1)/2; if(count == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i=left;i&lt;=right;i++)&#123; list.add(i); &#125; lists.add(list); left++; &#125;else if(count &gt; sum)&#123; left++; &#125;else &#123; right++; &#125; &#125; return lists; &#125; 26.扑克牌顺子 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 我的思路1234567891011121314151617181920212223242526272829public boolean isContinuous(int [] numbers) &#123; int count0=0; if(numbers.length==0)&#123; return false; &#125; int min =20; int max=0; for(int i=0;i&lt;numbers.length;i++)&#123; if(numbers[i]==0)&#123; count0++; &#125;else&#123; for(int k=i+1;k&lt;numbers.length;k++)&#123; if(numbers[i]==numbers[k])&#123; return false; &#125; &#125; max=max&lt;numbers[i]?numbers[i]:max; min=min&gt;numbers[i]?numbers[i]:min; &#125; &#125; if(count0==4)&#123; return true; &#125; if(max-min&lt;5)&#123; return true; &#125; return false; &#125; 27.不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 12345678public int Add(int num1,int num2) &#123; while (num2!=0) &#123; int temp = num1^num2; num2 = (num1&amp;num2)&lt;&lt;1; num1 = temp; &#125; return num1; &#125; 28.滑动窗口的最大值 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 我的思路123456789101112131415161718192021222324252627282930313233public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; int l=0,r=1; ArrayList&lt;Integer&gt; lists = new ArrayList&lt;Integer&gt;(); if(size ==1)&#123; for(int i=0;i&lt;num.length;i++)&#123; lists.add(num[i]); &#125; return lists; &#125; if(size == 0 || size &gt; num.length)&#123; return lists; &#125; int max=num[l]; while(r&lt;num.length &amp;&amp; l&lt;r)&#123; if(r-l&lt;size &amp;&amp; r&lt;num.length)&#123; max = max&gt;num[r]?max:num[r]; r++; &#125;else if(r-l==size)&#123; lists.add(max); if(max==num[l])&#123; int i=l+1;int k=r; max = num[i]; for(;i&lt;=k;i++)&#123; max=max&gt;num[i]?max:num[i]; &#125; &#125; l++; &#125; &#125; lists.add(max); return lists; &#125; 队列思路123456789101112131415161718192021222324252627282930import java.util.*;/**用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次1.判断当前最大值是否过期2.新增加的值从队尾开始比较，把所有比他小的值丢掉*/public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(size == 0) return res; int begin; ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for(int i = 0; i &lt; num.length; i++)&#123; begin = i - size + 1; if(q.isEmpty()) q.add(i); else if(begin &gt; q.peekFirst()) q.pollFirst(); while((!q.isEmpty()) &amp;&amp; num[q.peekLast()] &lt;= num[i]) q.pollLast(); q.add(i); if(begin &gt;= 0) res.add(num[q.peekFirst()]); &#125; return res; &#125;&#125; 29.剪绳子 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 我的思路1234567891011public int cutRope(int target) &#123; int max=1; if(target&lt;=3 &amp;&amp; target&gt;0)&#123; return target-1; &#125; while(target&gt;4)&#123; target-=3; max*=3; &#125; return max*target; &#125; 30.数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 我的思路1234567891011public boolean duplicate(int numbers[],int length,int [] duplication) &#123; int[] a = new int[length]; for(int i=0;i&lt;length;i++)&#123; a[numbers[i]]++; if(a[numbers[i]]==2)&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false; &#125; 不用辅助空间12345678910111213141516171819202122232425262728293031323334 /** * 数组的长度为 n 且所有数字都在 0 到 n-1 的范围内，我们可以将每次遇到的数进行"归位"，当某个数发现自己的"位置"被相同的数占了，则出现重复。 * 扫描整个数组，当扫描到下标为 i 的数字时，首先比较该数字（m）是否等于 i，如果是，则接着扫描下一个数字；如果不是，则拿 m 与第 m 个数比较。如果 m 与第 m 个数相等，则说明出现重复了；如果 m 与第 m 个数不相等，则将 m 与第 m 个数交换，将 m "归位"，再重复比较交换的过程，直到发现重复的数 * * 举个栗子： * 以数组 &#123;2,3,1,0,2,5,3&#125; 为例 * 当 i = 0 时，nums[i] = 2 != i，判断 nums[i] 不等于 nums[nums[i]]，交换 nums[i] 和 nums[nums[i]]，交换后数组为：&#123;1,3,2,0,2,5,3&#125; * 此时 i = 0，nums[i] = 1 != i，判断 nums[i] 不等于 nums[nums[i]]，交换 nums[i] 和 nums[nums[i]]，交换后数组为：&#123;3,1,2,0,2,5,3&#125; * 此时 i = 0，nums[i] = 3 != i，判断 nums[i] 不等于 nums[nums[i]]，交换 nums[i] 和 nums[nums[i]]，交换后数组为：&#123;0,1,2,3,2,5,3&#125; * 此时 i = 0，nums[i] = 0 = i，继续下一组 * 当 i = 1，nums[i] = 1 = i，继续下一组 * 当 i = 2，nums[i] = 2 = i，继续下一组 * 当 i = 3，nums[i] = 3 = i，继续下一组 * 当 i = 4，nums[i] = 2 != i，判断 nums[i] 等于 nums[nums[i]]，出现重复，赋值返回 * @param numbers * @param length * @param duplication * @return */ if(length&lt;=1)&#123; return false; &#125; for(int i=0;i&lt;length;i++)&#123; while(numbers[i] != i )&#123; if(numbers[i] == numbers[numbers[i]])&#123; duplication[0]=numbers[i]; return true; &#125; int temp = numbers[i]; numbers[i] = numbers[temp] ; numbers[temp]=temp; &#125; &#125; return false; 31.第一次只出现一次的字符 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 1234567891011121314public int FirstNotRepeatingChar(String str) &#123; int[] a= new int[58]; for(int i=0;i&lt;str.length();i++)&#123; int k=str.charAt(i)-'A'; a[k]++; &#125; for(int i=0;i&lt;str.length();i++)&#123; int k=str.charAt(i)-'A'; if(a[k]==1)&#123; return i; &#125; &#125; return -1; &#125; 32.数组的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 归并排序123456789101112131415161718192021222324252627282930313233 private int cnt; private void MergeSort(int[] array, int start, int end)&#123; if(start&gt;=end)return; int mid = (start+end)/2; MergeSort(array, start, mid); MergeSort(array, mid+1, end); MergeOne(array, start, mid, end); &#125; private void MergeOne(int[] array, int start, int mid, int end)&#123; int[] temp = new int[end-start+1]; int k=0,i=start,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;= end)&#123;//如果前面的元素小于后面的不能构成逆序对 if(array[i] &lt;= array[j]) temp[k++] = array[i++]; else&#123;//如果前面的元素大于后面的，那么在前面元素之后的元素都能和后面的元素构成逆序对 temp[k++] = array[j++]; cnt = (cnt + (mid-i+1))%1000000007; &#125; &#125; while(i&lt;= mid) temp[k++] = array[i++]; while(j&lt;=end) temp[k++] = array[j++]; for(int l=0; l&lt;k; l++)&#123; array[start+l] = temp[l]; &#125; &#125; public int InversePairs(int [] array) &#123; MergeSort(array, 0, array.length-1); return cnt; &#125; 33.两个链表的第一个公共结点 输入两个链表，找出它们的第一个公共结点。 HashMap1234567891011121314151617public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode res1= pHead1; ListNode res2=pHead2; HashMap&lt;ListNode,Integer&gt; hashMap = new HashMap&lt;ListNode, Integer&gt;(); while (res1!=null)&#123; hashMap.put(res1,res1.val); res1= res1.next; &#125; while(res2!=null)&#123; if(hashMap.containsKey(res2))&#123; return res2; &#125; res2= res2.next; &#125; return null; &#125; 同一起点因为如果两个链表会相交，后面的数据就相同。 123456789101112131415161718192021222324252627282930313233public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; int l1=getLength(pHead1); int l2=getLength(pHead2); if(l1&gt;l2)&#123; while(l2!=l1)&#123; pHead1=pHead1.next; l1--; &#125; &#125;else if(l1&lt;l2)&#123; while(l1!=l2)&#123; pHead2= pHead2.next; l1--; &#125; &#125; while(pHead1!=null &amp;&amp;pHead2!=null)&#123; if(pHead1==pHead2)&#123; return pHead1; &#125;else&#123; pHead1=pHead1.next; pHead2=pHead2.next; &#125; &#125; return null; &#125; public int getLength(ListNode head)&#123; int i=0; ListNode res= head; while(res!=null)&#123; i++; res= res.next; &#125; return i; &#125; 34.数字在排序数组中出现的次数 统计一个数字在排序数组中出现的次数。 12345678910111213141516171819public int GetNumberOfK(int [] array , int k) &#123; int res=0; int l=0,r=array.length-1; int mid =0; while(r&gt;=l)&#123; mid = (r+l)/2; if(array[mid]&lt;k)&#123; l=mid+1; &#125;else&#123; r=mid-1; &#125; &#125; while(l&lt;array.length &amp;&amp;array[l]==k )&#123; l++; res++; &#125; return res; &#125; 35.把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 12345678910111213141516171819202122public String PrintMinNumber(int [] numbers) &#123; if(numbers.length==0 || numbers==null)&#123; return ""; &#125; String res=""; String[] strings =new String[numbers.length]; for(int i=0;i&lt;numbers.length;i++)&#123; strings[i]=numbers[i]+""; &#125; Arrays.sort(strings,new Comparator&lt;String&gt;()&#123; public int compare(String o1, String o2) &#123; String c1 = o1 + o2; String c2 = o2 + o1; return c1.compareTo(c2); &#125; &#125;); for (String a: strings) &#123; res=res+a; &#125; return res;&#125; 36.丑数把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 12345678910111213141516171819202122232425262728/** * 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z， * 换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数， * 在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方***得到重复的丑数，而且我们题目要求第N个丑数， * 这样的方法得到的丑数也是无序的。那么我们可以维护三个队列： * 疑问： * 1.为什么分三个队列？ * 丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的； * 2.为什么比较三个队列头部最小的数放入丑数数组？ * 因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。 * 实现思路： * 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组； */ public int GetUglyNumber_Solution(int index) &#123; if(index==0)&#123; return 0; &#125; int[] a =new int[index]; int p2=0,p3=0,p5=0; a[0]=1; for(int i=1;i&lt;index;i++)&#123; a[i] =Math.min(Math.min(a[p2]*2,a[p3]*3),a[p5]*5); if(a[p2]*2==a[i]) p2++; if(a[p3]*3==a[i]) p3++; if(a[p5]*5==a[i]) p5++; &#125; return a[index-1]; &#125; 37.翻转单词顺序列牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 1234567891011121314public String ReverseSentence(String str) &#123; if(str.trim().equals(""))&#123; return str; &#125; String[] strings = str.split(" "); String res=""; for(int i=strings.length-1;i&gt;=0;i--)&#123; res+=strings[i]; if(i&gt;=1)&#123; res+=" "; &#125; &#125; return res; &#125; 38.数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/**先用java集合PriorityQueue来设置一个小顶堆和大顶堆主要的思想是：因为要求的是中位数，那么这两个堆，大顶堆用来存较小的数，从大到小排列；小顶堆存较大的数，从小到大的顺序排序*，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。⭐保证：小顶堆中的元素都大于等于大顶堆中的元素，所以每次塞值，并不是直接塞进去，而是从另一个堆中poll出一个最大（最小）的塞值⭐当数目为偶数的时候，将这个值插入大顶堆中，再将大顶堆中根节点（即最大值）插入到小顶堆中；⭐当数目为奇数的时候，将这个值插入小顶堆中，再讲小顶堆中根节点（即最小值）插入到大顶堆中；⭐取中位数的时候，如果当前个数为偶数，显然是取小顶堆和大顶堆根结点的平均值；如果当前个数为奇数，显然是取小顶堆的根节点理解了上面所述的主体思想，下面举个例子辅助验证一下。例如，传入的数据为：[5,2,3,4,1,6,7,0,8],那么按照要求，输出是"5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 "那么整个程序的执行流程应该是（用min表示小顶堆，max表示大顶堆）：5先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[5],max=[无]，avg=[5.00]2先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[5],max=[2],avg=[(5+2)/2]=[3.50]3先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[3,5],max=[2],avg=[3.00]4先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[4,5],max=[3,2],avg=[(4+3)/2]=[3.50]1先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[3,4,5],max=[2,1]，avg=[3/00]6先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[4,5,6],max=[3,2,1],avg=[(4+3)/2]=[3.50]7先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[4,5,6,7],max=[3,2,1],avg=[4]=[4.00]0先进入小顶堆，然后将小顶堆中最大值放入小顶堆中，此时min=[4,5,6,7],max=[3,2,1,0],avg=[(4+3)/2]=[3.50]8先进入大顶堆，然后将大顶堆中最小值放入大顶堆中，此时min=[4,5,6,7,8],max=[3,2,1,0],avg=[4.00]**/import java.util.PriorityQueue;import java.util.Comparator;public class Solution &#123; //小顶堆 private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;Integer&gt;(); //大顶堆 private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(15, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); //记录偶数个还是奇数个 int count = 0; //每次插入小顶堆的是当前大顶堆中最大的数 //每次插入大顶堆的是当前小顶堆中最小的数 //这样保证小顶堆中的数永远大于等于大顶堆中的数 //中位数就可以方便地从两者的根结点中获取了 public void Insert(Integer num) &#123; //个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中 if(count % 2 == 0)&#123; maxHeap.offer(num); int max = maxHeap.poll(); minHeap.offer(max); &#125;else&#123; //个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中 minHeap.offer(num); int min = minHeap.poll(); maxHeap.offer(min); &#125; count++; &#125; public Double GetMedian() &#123; //当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均 if(count % 2 == 0)&#123; return new Double(minHeap.peek() + maxHeap.peek())/2; &#125;else&#123; //当前为奇数个，则直接从小顶堆中取元素即可 return new Double(minHeap.peek()); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 03]]></title>
    <url>%2F2020%2F01%2F14%2F%E5%89%91%E6%8C%87offer%20%2003%2F</url>
    <content type="text"><![CDATA[剑指offer 0339.重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解法一：12345678910111213141516171819import java.util.Arrays;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length==0)&#123; return null; &#125; TreeNode tree =new TreeNode(pre[0]); for(int i=0;i&lt;in.length;i++)&#123; if(pre[0]==in[i])&#123; tree.left=reConstructBinaryTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i)); tree.right = reConstructBinaryTree(Arrays.copyOfRange(pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); &#125; &#125; return tree; &#125;&#125; 解法二1234567891011121314151617181920public TreeNode reConstructBinaryTree(int [] pre, int [] in) &#123; TreeNode treeNode =reConstructint(pre,0,pre.length-1,in,0,in.length-1); return treeNode; &#125; private TreeNode reConstructint(int[] pre, int startpre,int endpre,int[] in,int startin,int endin )&#123; if(startpre&gt;=endpre || startin&gt;=endin)&#123; return null; &#125; TreeNode root=new TreeNode(pre[startpre]); for(int i=startin;startin&lt;=endin;i++)&#123; if(in[i]==pre[startpre])&#123; root.left=reConstructint(pre,startpre+1,startpre+i-startin,in,startin,i-1); root.right=reConstructint(pre,i-startin+startpre+1,endpre,in,i+1,endin); break; &#125; &#125; return root; &#125; 40.栈的压入，弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 1234567891011121314151617import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; int n= pushA.length; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int j=0; for(int i=0;i&lt;n;i++)&#123; stack.push(pushA[i]); while(j&lt;popA.length &amp;&amp; stack.peek()==popA[j])&#123; stack.pop(); j++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 41.从上往下打印二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。 使用链表实现12345678910111213141516171819public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; lists = new ArrayList&lt;Integer&gt;(); if(root==null)&#123; return lists; &#125; ArrayList&lt;TreeNode&gt; queue= new ArrayList&lt;TreeNode&gt;(); queue.add(root); while(queue.size()!=0)&#123; TreeNode temp = queue.remove(0); if(temp.left!=null)&#123; queue.add(temp.left); &#125; if(temp.right!=null)&#123; queue.add(temp.right); &#125; lists.add(temp.val); &#125; return lists; &#125; 队列方法12345678910111213141516171819public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; lists = new ArrayList&lt;Integer&gt;(); if(root==null)&#123; return lists; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(root.right); &#125; lists.add(node.val); &#125; return lists;&#125; 42.二叉搜索树的后序遍历输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920public boolean VerifySquenceOfBST(int [] sequence) &#123; int n=sequence.length; if(n==0) return false; if(n==1) return true; return help(sequence,0,n-1);&#125;private boolean help(int[] a,int start,int end)&#123; if(start&gt;=end)return true; int i=start; while(a[i]&lt;a[end])&#123; i++; &#125; for(int j=i;j&lt;end;j++)&#123; if(a[j]&lt;a[end])&#123; return false; &#125; &#125; return help(a,start,i-1)&amp;&amp;help(a,i,end-1);&#125; 43.二叉树中和为某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listsAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(root==null)&#123; return listsAll; &#125; help(listsAll,new ArrayList&lt;Integer&gt;(),root,target); return listsAll; &#125; private void help(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listsAll, ArrayList&lt;Integer&gt; lists, TreeNode root, int target) &#123; if(root==null || target&lt;0) return; target -=root.val; lists.add(root.val); if(target==0 &amp;&amp; root.right==null &amp;&amp; root.left==null)&#123; listsAll.add(lists); return; &#125; ArrayList&lt;Integer&gt; list2= new ArrayList&lt;Integer&gt;(); list2.addAll(lists); help(listsAll,lists,root.left,target); help(listsAll,list2,root.right,target); &#125;&#125; 解法二：12345678910111213private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return listAll; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1); return listAll;&#125; 44.二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112public void Mirror(TreeNode root) &#123; if(root==null)&#123; return; &#125; if(root.left==null &amp;&amp; root.right==null) return; TreeNode temp=root.left; root.left=root.right; root.right=temp; Mirror(root.left); Mirror(root.right); &#125; 45.整数中1出现的次数（从1 到 n 中1出现的次数）求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 个位 * 我们知道在个位数上，1会每隔10出现一次，例如1、11、21等等，我们发现以10为一个阶梯的话，每一个完整的阶梯里面都有一个1，例如数字22，按照10为间隔来分三个阶梯，在完整阶梯0-9，10-19之中都有一个1，但是19之后有一个不完整的阶梯，我们需要去判断这个阶梯中会不会出现1，易推断知，如果最后这个露出来的部分小于1，则不可能出现1（这个归纳换做其它数字也成立）。 * * 我们可以归纳个位上1出现的个数为： * * n/10 * 1+(n%10!=0 ? 1 : 0) * * 十位 * 现在说十位数，十位数上出现1的情况应该是10-19，依然沿用分析个位数时候的阶梯理论，我们知道10-19这组数，每隔100出现一次，这次我们的阶梯是100，例如数字317，分析有阶梯0-99，100-199，200-299三段完整阶梯，每一段阶梯里面都会出现10次1（从10-19），最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于19，那么直接算10个1就行了，因为10-19肯定会出现；如果小于10，那么肯定不会出现十位数的1；如果在10-19之间的，我们计算结果应该是k - 10 + 1。例如我们分析300-317，17个数字，1出现的个数应该是17-10+1=8个。 * * 那么现在可以归纳：十位上1出现的个数为： * * 设k = n % 100，即为不完整阶梯段的数字 * 归纳式为：(n / 100) * 10 + (if(k &gt; 19) 10 else if(k &lt; 10) 0 else k - 10 + 1) * 百位 * 现在说百位1，我们知道在百位，100-199都会出现百位1，一共出现100次，阶梯间隔为1000，100-199这组数，每隔1000就会出现一次。这次假设我们的数为2139。跟上述思想一致，先算阶梯数 * 完整阶梯中1在百位出现的个数，即n/1000 * 100得到前两个阶梯中1的个数，那么再算漏出来的部分139，沿用上述思想，不完整阶梯数k199，得到100个百位1，100&lt;=k&lt;=199则得到k - 100 + 1个百位1。 * * 那么继续归纳百位上出现1的个数： * * 设k = n % 1000 * 归纳式为：(n / 1000) * 100 + (if(k &gt;199) 100 else if(k &lt; 100) 0 else k - 100 + 1) * 后面的依次类推.... * * 再次回顾个位 * 我们把个位数上算1的个数的式子也纳入归纳式中 * * k = n % 10 * 个位数上1的个数为：n / 10 * 1 + (if(k &gt; 1) 1 else if(k &lt; 1) 0 else k - 1 + 1) * 完美！归纳式看起来已经很规整了。 来一个更抽象的归纳，设i为计算1所在的位数，i=1表示计算个位数的1的个数，10表示计算十位数的1的个数等等。 * * k = n % (i * 10) * count(i) = (n / (i * 10)) * i + (if(k &gt; i * 2 - 1) i else if(k &lt; i) 0 else k - i + 1) * 好了，这样从10到10的n次方的归纳就完成了。 * * sum1 = sum(count(i))，i = Math.pow(10, j), 0&lt;=j&lt;=log10(n) * 但是有一个地方值得我们注意的，就是代码的简洁性来看，有多个ifelse不太好，能不能进一步简化呢？ 我们可以把后半段简化成这样，我们不去计算i * 2 - 1了，我们只需保证k - i + 1在[0, i]区间内就行了，最后后半段可以写成这样 * * min(max((n mod (i*10))−i+1,0),i) */public int NumberOf1Between1AndN_Solution(int n) &#123; if(n &lt;= 0) return 0; int count = 0; for(long i = 1; i &lt;= n; i *= 10)&#123; long diviver = i * 10; count += (n / diviver) * i + Math.min(Math.max(n % diviver - i + 1, 0), i); &#125; return count; &#125; 46.二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 递归版本1234567891011121314151617181920212223242526// 记录子树链表的最后一个节点，终结点只可能为只含左子树的非叶节点与叶节点 protected TreeNode leftLast = null; public TreeNode Convert(TreeNode root) &#123; if(root==null) return null; if(root.left==null&amp;&amp;root.right==null)&#123; leftLast = root;// 最后的一个节点可能为最右侧的叶节点 return root; &#125; // 1.将左子树构造成双链表，并返回链表头节点 TreeNode left = Convert(root.left); // 3.如果左子树链表不为空的话，将当前root追加到左子树链表 if(left!=null)&#123; leftLast.right = root; root.left = leftLast; &#125; leftLast = root;// 当根节点只含左子树时，则该根节点为最后一个节点 // 4.将右子树构造成双链表，并返回链表头节点 TreeNode right = Convert(root.right); // 5.如果右子树链表不为空的话，将该链表追加到root节点之后 if(right!=null)&#123; right.left = root; root.right = right; &#125; return left!=null?left:root; &#125; 47.二叉树深度输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 递归：12345678910public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; int left=TreeDepth(root.left); int right=TreeDepth(root.right); return Math.max(left,right)+1; &#125;&#125; 非递归：12345678910111213141516171819202122232425public int TreeDepth(TreeNode root) &#123; int res=0; if(root==null)&#123; return res; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); int count=0,nextCount=1; while(!queue.isEmpty())&#123; TreeNode top = queue.poll(); count++; if(top.left!=null)&#123; queue.add(top.left); &#125; if(top.right!=null)&#123; queue.add(top.right); &#125; if(count==nextCount)&#123; count=0; nextCount=queue.size(); res++; &#125; &#125; return res; &#125; 48.平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 123456789101112131415161718private boolean isBalanced=true; public boolean IsBalanced_Solution(TreeNode root) &#123; getDepth(root); return isBalanced; &#125; public int getDepth(TreeNode root)&#123; if(root==null) return 0; int left=getDepth(root.left); int right=getDepth(root.right); if(Math.abs(left-right)&gt;1)&#123; isBalanced=false; &#125; return right&gt;left ?right+1:left+1; &#125; 49.把字符串转换成整数将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 12345678910111213141516171819202122232425262728293031public int StrToInt(String str) &#123; long sum=0; int l=str.length(); if(l==0)&#123; return 0; &#125; for(int i=1;i&lt;str.length();i++)&#123; if(str.charAt(i)&lt;='9'&amp;&amp;'0'&lt;=str.charAt(i))&#123; if(str.charAt(0)=='-')&#123; sum= (long) (sum-(str.charAt(i)-'0')*Math.pow(10,l-i-1)); &#125;else &#123; sum= (long) (sum+(str.charAt(i)-'0')*Math.pow(10,l-i-1)); &#125; &#125;else&#123; return 0; &#125; &#125; if(str.charAt(0)=='-' || str.charAt(0)=='+')&#123; if(sum&gt;Integer.MAX_VALUE || sum&lt;Integer.MIN_VALUE)&#123; return 0; &#125; return (int)sum; &#125;else if(str.charAt(0)&lt;='9'&amp;&amp; str.charAt(0)&gt;='0')&#123; sum= (long) (sum+(str.charAt(0)-'0')*Math.pow(10,l-1)); if(sum&gt;Integer.MAX_VALUE ) return 0; return (int)sum; &#125; return 0; &#125; 50.搭建乘积数组给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。 12345678910111213public int[] multiply(int[] A) &#123; int[] B=new int[A.length]; B[0]=1; for(int i=1;i&lt;A.length;i++)&#123; B[i]=B[i-1]*A[i-1]; &#125; int temp=1; for(int k=A.length-2;k&gt;=0;k--)&#123; temp*=A[k+1]; B[k]*=temp; &#125; return B; &#125;]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 01]]></title>
    <url>%2F2020%2F01%2F14%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer1.二维数组中查找 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567public boolean Find(int target, int [][] array) &#123; if(array.length == 0 || array[0].length==0)&#123; return false; &#125; int h=array.length; int l=array[0].length; 123456789101112131415161718192021222324252627282930313233 if(target &lt; array[0][0] || target &gt;array[h-1][l-1])&#123; return false; &#125; int i=0,k=0; while(i&gt;=0 &amp;&amp; k&gt;=0 &amp;&amp; i &lt; h &amp;&amp; k&lt;l)&#123; if(target &lt; array[i][k])&#123; break; &#125; if(target == array[i][k])&#123; return true; &#125; i++;k++; &#125; for(int j=i;j&lt;h;j++)&#123; for(int a=k; a&gt;=0;a--)&#123; if(target == array[j][a])&#123; return true; &#125;else if(target &gt; array[j][a])&#123; break; &#125; &#125; &#125; for(int j=k;j&gt;=0;j--)&#123; for(int a=i; a&gt;l;a++)&#123; if(target == array[j][a])&#123; return true; &#125;else if(target &lt; array[j][a])&#123; break; &#125; &#125; &#125; return false;&#125;` 2.替换空格 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1234public String replaceSpace(StringBuffer str) &#123; String res=str.toString(); return res.replaceAll(" ","%20"); &#125; 3.从尾到头打印链表 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 1234567891011public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.add(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) ret.add(stack.pop()); return ret; &#125; 4.重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 5.用两个栈实现队列 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314151617181920import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; while(!stack2.empty())&#123; stack1.push(stack2.pop()); &#125; stack1.push(node); &#125; public int pop() &#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125;&#125; 6.旋转数组的最小数 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 我的思路12345678910public static int minNumberInRotateArray(int [] array) &#123; int res=0; for(int i=0;i&lt;array.length-1;i++)&#123; if(array[i+1]&lt;array[i])&#123; return array[i+1]; &#125; &#125; return res; &#125; 时间复杂度为O(n); 二分思路123456789101112131415public int minNumberInRotateArray(int [] array) &#123; int left=0; int right=array.length - 1; while(left&lt;right)&#123; int mid= (left+right)/2; if(array[right]&lt;array[mid])&#123; left = mid+1; &#125;else if(array[right]&gt;array[mid])&#123; right=mid; &#125;else&#123; right--; &#125; &#125; return array[left]; &#125; 时间复杂度为O(log^n); 7.斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 123456789public int Fibonacci(int n) &#123; if(n==0)&#123; return 0; &#125;else if(n==1)&#123; return 1; &#125;else&#123; return Fibonacci(n-1)+Fibonacci(n-2); &#125; &#125; 8.数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 123456789101112131415public double Power(double base, int exponent) &#123; int n=exponent;double res=base; if(base==0)&#123; return 0; &#125;else if(n&lt;0)&#123; n = -exponent; &#125;else if(n==0)&#123; return 1; &#125; while(n&gt;1)&#123; res=res*base; n--; &#125; return exponent&gt;0?res:1.0/res;&#125; 9.调整数组顺序使奇数位位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 我的思路（扩增一个数组）1234567891011121314public void reOrderArray(int [] array) &#123; int[] a=new int[array.length]; int l=0,r=0; for(int i=0;i&lt;array.length;i++)&#123; if(array[i]%2==0)&#123; a[r++]=array[i]; &#125;else&#123; array[l++]=array[i]; &#125; &#125; for(int i=0;i&lt;r;i++)&#123; array[l++]=a[i]; &#125; &#125; 其他思路（冒泡）123456789101112131415public void reOrderArray(int [] array) &#123; int k=0; for(int i=0;i&lt;array.length;i++)&#123; if(array[i]%2!=0)&#123; int j=i; while(j&gt;k)&#123; int temp =array[j]; array[j]=array[j-1]; array[j-1]=temp; j--; &#125; k++; &#125; &#125; &#125; 10.链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个结点。 双结点思路123456789101112public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode p, q; p=q=head; int i=0; while(p !=null)&#123; if(i&gt;=k) q=q.next; p=p.next; i++; &#125; return i&lt;k?null:q;&#125; 11.反转链表 输入一个链表，反转链表后，输出新链表的表头。 12345678910111213141516171819202122232425262728293031public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null)&#123; //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; &#125; //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre; &#125; 12.合并两个排序的链表 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 递归123456789101112131415public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1==null)&#123; return list2; &#125; if(list2==null)&#123; return list1; &#125; if(list1.val &lt;= list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next =Merge(list1,list2.next); return list2; &#125; &#125; 非递归1234567891011121314151617181920212223242526272829303132333435if(list1==null)&#123; return list2; &#125; if(list2==null)&#123; return list1; &#125; ListNode head; ListNode p; if(list1.val &lt; list2.val)&#123; head =list1; list1= list1.next; &#125;else&#123; head = list2; list2=list2.next; &#125; p=head; while(list1!=null &amp;&amp; list2!=null)&#123; if(list1.val &lt; list2.val)&#123; head.next=list1; list1=list1.next; head= head.next; &#125;else&#123; head.next=list2; list2=list2.next; head=head.next; &#125; &#125; if(list1!=null)&#123; head.next=list1; &#125; if(list2!=null)&#123; head.next=list2; &#125; return p; &#125; 13.树的子结构 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 1234567891011121314151617181920public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root1==null || root2==null)&#123; return false; &#125; return isSubtree(root1,root2)||HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2); &#125; public boolean isSubtree(TreeNode root1,TreeNode root2)&#123; if(root2==null)&#123; return true; &#125; if(root1==null)&#123; return false; &#125; if(root1.val == root2.val)&#123; return isSubtree(root1.left,root2.left) &amp;&amp; isSubtree(root1.right,root2.right); &#125;else&#123; return false; &#125; &#125; 14.顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(matrix == null || matrix.length == 0 || matrix[0].length == 0)&#123; return list; &#125; int up = 0; int down = matrix.length-1; int left = 0; int right = matrix[0].length-1; while(true)&#123; // 最上面一行 for(int col=left;col&lt;=right;col++)&#123; list.add(matrix[up][col]); &#125; // 向下逼近 up++; // 判断是否越界 if(up &gt; down)&#123; break; &#125; // 最右边一行 for(int row=up;row&lt;=down;row++)&#123; list.add(matrix[row][right]); &#125; // 向左逼近 right--; // 判断是否越界 if(left &gt; right)&#123; break; &#125; // 最下面一行 for(int col=right;col&gt;=left;col--)&#123; list.add(matrix[down][col]); &#125; // 向上逼近 down--; // 判断是否越界 if(up &gt; down)&#123; break; &#125; // 最左边一行 for(int row=down;row&gt;=up;row--)&#123; list.add(matrix[row][left]); &#125; // 向右逼近 left++; // 判断是否越界 if(left &gt; right)&#123; break; &#125; &#125; return list; &#125; 15.包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 12345678910111213141516171819202122232425262728293031import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); if(stack2.isEmpty() || stack2.peek()&gt;node)&#123; stack2.push(node); &#125;else&#123; stack2.push(stack2.peek()); &#125; &#125; public void pop() &#123; stack1.pop(); stack2.pop(); &#125; public int top() &#123; return stack1.peek(); &#125; public int min() &#123; return stack2.peek(); &#125;&#125; 16.栈的压入，弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 17.最小的K个数 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 冒泡排序：12345678910111213141516171819public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(k&gt;input.length)&#123; return list; &#125; for(int i=0;i&lt;k;i++)&#123; for(int j=i+1;j&lt;input.length;j++)&#123; if(input[i]&gt;input[j])&#123; int item=input[i]; input[i]=input[j]; input[j]=item; &#125; &#125; list.add(input[i]); &#125; return list; &#125; 18.连续子数组的最大和 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 123456789101112131415161718192021public int FindGreatestSumOfSubArray(int[] array) &#123; int max = 0; if(array.length==0)&#123; return max; &#125; int sum = array[0]; for(int i = 1; i &lt; array.length; i++) &#123; sum=array[i]&gt;sum?array[i]:sum; &#125; if(sum&lt;=0) return sum; sum=0; for(int i = 0; i &lt; array.length; i++) &#123; sum+=array[i]; if(sum&lt;0)&#123; sum=0; &#125; max=max&lt;sum?sum:max; &#125; return max; &#125; 19.求1+2+3+…+n 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 12345public int Sum_Solution(int n) &#123; int ans = n; boolean t=((ans!=0) &amp;&amp; ((ans += Sum_Solution(n - 1))!=0)); return ans; &#125; 20.孩子们的游戏每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 如果没有小朋友，请返回-1 123456789101112131415public int LastRemaining_Solution(int n, int m) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if(n&lt;=0||m&lt;=0)&#123; return -1; &#125; for(int i=0;i&lt;n;i++)&#123; list.add(i); &#125; int temp=0; while(list.size()&gt;1)&#123; temp=(temp+m-1)%list.size(); list.remove(temp); &#125; return list.get(0); &#125; 21.和为S的两个数字输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述: 1对应每个测试案例，输出两个数，小的先输出。 我方思路12345678910111213141516171819202122232425public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int max=10000000; int l=-1,r=-1; for(int i=0;i&lt;array.length;i++)&#123; for(int j=i+1;j&lt;array.length;j++)&#123; if(array[i]+array[j]==sum)&#123; if(max&gt;=array[i]*array[j])&#123; l=i; r=j; max=array[i]*array[j]; &#125; break; &#125; if(array[i]+array[j]&gt;sum) break; &#125; &#125; if(l==-1)&#123; return list; &#125; list.add(array[l]); list.add(array[r]); return list; &#125; 更好思路1234567891011121314151617181920public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(array.length&lt;2)&#123; return list; &#125; int i=0,j=array.length-1; while(i&lt;j)&#123; if(array[i]+array[j]==sum)&#123; list.add(array[i]); list.add(array[j]); break; &#125; if(array[i]+array[j]&gt;sum)&#123; j--; &#125;else&#123; i++; &#125; &#125; return list; &#125; 22.字符串的排序 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 回溯算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /** * 1、递归算法 * * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html (感谢该文作者！) * * 对于无重复值的情况 * * 固定第一个字符，递归取得首位后面的各种字符串组合； * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。 * * 假如有重复值呢？ * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。 * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。 * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。 * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。 * * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数， * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！ * * * @param str * @return */public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; list= new ArrayList&lt;String&gt;(); if(str.length()&gt;1)&#123; PermutationHelper(str.toCharArray(),0,list); Collections.sort(list); &#125;else if(str.length()==1)&#123; list.add(str); &#125; return list; &#125; public void PermutationHelper(char[] a,int i,ArrayList&lt;String&gt; list) &#123; if(i==a.length-1)&#123; list.add(String.valueOf(a)); &#125; Set&lt;Character&gt; charSet = new HashSet&lt;Character&gt;(); for(int j=i;j&lt;a.length;j++)&#123; if(j==i || !charSet.contains(a[j]))&#123; charSet.add(a[j]); swap(a,i,j); PermutationHelper(a,i+1,list); swap(a,j,i); &#125; &#125; &#125; private void swap(char[] a, int i, int j) &#123; char temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; 字典序排列算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /** * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html （感谢作者） * * 一个全排列可看做一个字符串，字符串可有前缀、后缀。 * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。 * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。 * * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321， * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。 * * 【例】 如何得到346987521的下一个 * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置 * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1 * 最终找到6是第一个变小的数字，记录下6的位置i-1 * * 2，从i位置往后找到最后一个大于6的数 * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1 * 最终找到7的位置，记录位置为m * * 3，交换位置i-1和m的值 * 3 4 7 9 8 6 5 2 1 * 4，倒序i位置后的所有数据 * 3 4 7 1 2 5 6 8 9 * 则347125689为346987521的下一个排列 * * @param str * @return */ public ArrayList&lt;String&gt; Permutation2(String str)&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); if(str==null || str.length()==0)&#123; return list; &#125; char[] chars = str.toCharArray(); Arrays.sort(chars); list.add(String.valueOf(chars)); int len = chars.length; while(true)&#123; int lIndex = len-1; int rIndex; while(lIndex&gt;=1 &amp;&amp; chars[lIndex-1]&gt;=chars[lIndex])&#123; lIndex--; &#125; if(lIndex == 0) break; rIndex = lIndex; while(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-1])&#123; rIndex++; &#125; swap(chars,lIndex-1,rIndex-1); reverse(chars,lIndex); list.add(String.valueOf(chars)); &#125; return list; &#125; private void reverse(char[] chars,int k)&#123; if(chars==null || chars.length&lt;=k) return; int len = chars.length; for(int i=0;i&lt;(len-k)/2;i++)&#123; int m = k+i; int n = len-1-i; if(m&lt;=n)&#123; swap(chars,m,n); &#125; &#125; &#125; 23.数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 我的思路1234567891011121314151617181920public int MoreThanHalfNum_Solution(int [] array) &#123; Arrays.sort(array); int count=1; if(array.length==1)&#123; return array[0]; &#125; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]==array[i-1])&#123; count++; if(count&gt;array.length/2)&#123; return array[i]; &#125; &#125;else&#123; System.out.println(count); count=1; &#125; &#125; return 0; &#125; 24.数组中只出现一次的数字 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 我方思路123456789101112131415161718192021222324252627282930public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int l=array.length; for(int i=0;i&lt;l;i++)&#123; for(int j=0;j&lt;l-i-1;j++)&#123; if(array[j]&gt;array[j+1])&#123; int temp=array[j]; array[j] = array[j+1]; array[j+1]=temp; &#125; &#125; &#125; int i=0; boolean flag=true; while(i&lt;l-1)&#123; if(array[i]== array[i+1] )&#123; i+=2; &#125;else if(array[i]!=array[i+1]&amp;&amp; flag)&#123; num1[0] = array[i]; i++; flag=false; &#125;else if(!false &amp;&amp; array[i]!=array[i+1])&#123; num2[0]=array[i]; break; &#125; &#125; if(i&gt;=l-1)&#123; num2[0]=array[l-1]; &#125; &#125;]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer 04]]></title>
    <url>%2F2020%2F01%2F14%2F%E5%89%91%E6%8C%87offer%2004%2F</url>
    <content type="text"><![CDATA[剑指offer 0451.正则表达式匹配请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /** * 当模式中的第二个字符不是“*”时： * 1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 * 2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 * * 而当模式中的第二个字符是“*”时： * 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： * 1、模式后移2字符，相当于x*被忽略； * 2、字符串后移1字符，模式后移2字符； * 3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； * * 这里需要注意的是：Java里，要时刻检验数组是否越界。 */链接：https://www.nowcoder.com/questionTerminal/45327ae22b7b413ea21df13ee7d6429c?f=discussion来源：牛客网public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) &#123; return false; &#125; int strIndex = 0; int patternIndex = 0; return matchCore(str, strIndex, pattern, patternIndex);&#125; public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; //有效性检验：str到尾，pattern到尾，匹配成功 if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123; return true; &#125; //pattern先到尾，匹配失败 if (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123; return false; &#125; //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位 if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; //模式后移2，视为x*匹配0个字符 return matchCore(str, strIndex, pattern, patternIndex + 2) //视为模式匹配1个字符 || matchCore(str, strIndex + 1, pattern, patternIndex + 2) //*匹配1个，再匹配str中的下一个 || matchCore(str, strIndex + 1, pattern, patternIndex); &#125; else &#123; return matchCore(str, strIndex, pattern, patternIndex + 2); &#125; &#125; //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex + 1, pattern, patternIndex + 1); &#125; return false; &#125;&#125; 52.表示数值的字符串请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 123456789101112131415161718192021222324252627282930313233343536373839404142public static boolean isNumeric(char[] str) &#123; int n=str.length; if(n==0)&#123; return false; &#125; if(n==1)&#123; if(str[0]&gt;'9' || str[0]&lt;'0' )&#123; return false; &#125; &#125; boolean flag=true; boolean flag1=true; for(int i=0;i&lt;n;i++)&#123; if(str[i]&gt;'9' || str[i]&lt;'0' )&#123; if(str[i]!='+' &amp;&amp; str[i]!='-' &amp;&amp; str[i]!='e' &amp;&amp; str[i]!='E' &amp;&amp; str[i]!='.')&#123; return false; &#125; &#125; if(i&gt;=1 &amp;&amp; (str[i]=='+'||str[i]=='-'))&#123; if(str[i-1]!='e'&amp;&amp; str[i-1]!='E') &#123; return false; &#125; &#125; if(str[i]=='e'|| str[i]=='E')&#123; if(!flag || i==n-1)&#123; return false; &#125; flag=false; &#125; if(str[i]=='.')&#123; if(!flag ||i==0)&#123; return false; &#125; if(flag1)&#123; flag1=false; &#125;else&#123; return false; &#125; &#125; &#125; return true; &#125; 53.字符流中第一个不重复的字符请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 1234567891011121314151617181920//Insert one char from stringstreamprivate String s="";private char[] chars = new char[256];public void Insert(char ch)&#123; s+=ch; chars[ch]++;&#125;//return the first appearence once char in current stringstreampublic char FirstAppearingOnce()&#123; int n=s.length(); for(int i=0;i&lt;n;i++)&#123; if(chars[s.charAt(i)]==1)&#123; return s.charAt(i); &#125; &#125; return '#';&#125; 54.链表中环的入口给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * * 思路： * 设置快慢指针，都从链表头出发，快指针每次走两步，慢指针一次走一步，假如有环，一定相遇于环中某点(结论1)。接着让两个指针分别从相遇点和链表头出发，两者都改为每次走一步，最终相遇于环入口(结论2)。以下是两个结论证明： * 两个结论： * 1、设置快慢指针，假如有环，他们最后一定相遇。 * 2、两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。 * 证明结论1：设置快慢指针fast和low，fast每次走两步，low每次走一步。假如有环，两者一定会相遇（因为low一旦进环，可看作fast在后面追赶low的过程，每次两者都接近一步，最后一定能追上）。 * 证明结论2： * 设： * 链表头到环入口长度为--a * 环入口到相遇点长度为--b * 相遇点到环入口长度为--c * * 则：相遇时 * 快指针路程=a+(b+c)k+b ，k&gt;=1 其中b+c为环的长度，k为绕环的圈数（k&gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。 * 慢指针路程=a+b * 快指针走的路程是慢指针的两倍，所以： * （a+b）*2=a+(b+c)k+b * 化简可得： * a=(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度。其中k&gt;=1,所以k-1&gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。 */public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode lower=pHead; ListNode faster =pHead; while(faster!=null &amp;&amp; faster.next!=null)&#123; faster=faster.next.next; lower=lower.next; if(faster==lower)&#123; break; &#125; &#125; if(faster==null||faster.next==null )&#123; return null; &#125; faster=pHead; while(faster!=lower)&#123; faster=faster.next; lower = lower.next; &#125; return faster; &#125; 55.左旋转字符串汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 内置函数12345678910public String LeftRotateString(String str,int n) &#123; int len =str.length(); if(n&gt;=str.length() || str.length()==0 || str.length()==1)&#123; return str; &#125; char[] a=str.toCharArray(); String temp=str.substring(0,n);; str=str.substring(n); return str+temp;&#125; 非内置函数12345678910111213141516171819202122232425262728public String LeftRotateString(String str,int n) &#123; int len =str.length(); if(n&gt;=str.length() || str.length()==0 || str.length()==1)&#123; return str; &#125; char[] a=str.toCharArray(); for(int i=0,j=n-1;i&lt;j;j--,i++)&#123; swap(a,i,j); &#125; for(int i=n,j=len-1;i&lt;j;i++,j--)&#123; swap(a,i,j); &#125; for(int i=0,j=len-1;i&lt;j;i++,j--)&#123; swap(a,i,j); &#125; String res=""; for (char k: a) &#123; res+=k; &#125; return res; &#125; private void swap(char[] str, int i, int j) &#123; char temp=str[i]; str[i]=str[j]; str[j]=temp; &#125; 56.删除链表中重复的结点在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910111213141516171819202122232425262728/** * 1. 首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况 * * 2.设置 pre ，last 指针， pre指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。 */public ListNode deleteDuplication(ListNode pHead) &#123; if(pHead==null || pHead.next==null )&#123; return pHead; &#125; ListNode Head=new ListNode(0); Head.next = pHead; ListNode pre = Head; ListNode last = Head.next; while (last!=null)&#123; if(last.next!=null &amp;&amp; last.val==last.next.val)&#123; while (last.next!=null &amp;&amp; last.val==last.next.val)&#123; last=last.next; &#125; pre.next=last.next; last=last.next; &#125;else&#123; pre = pre.next; last=last.next; &#125; &#125; return Head.next; &#125; 57.二叉树的下一个结点给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 1234567891011121314151617181920212223/** * 分析二叉树的下一个节点，一共有以下情况： * 1.二叉树为空，则返回空； * 2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； * 3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 */ public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode == null) return null; TreeLinkNode res; if(pNode.right == null)&#123; res = pNode; while(res.next != null &amp;&amp; res.next.right == res)&#123; res = res.next; &#125; return res.next; &#125; res = pNode.right; while(res.left != null)&#123; res = res.left; &#125; return res; &#125; 58.对称的二叉树请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 12345678910111213141516boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot==null)&#123; return true; &#125; return help(pRoot.left,pRoot.right); &#125; private boolean help(TreeNode left, TreeNode right) &#123; if(left==null &amp;&amp; right==null)&#123; return true; &#125;else if((left!=null &amp;&amp; right==null)||(right!=null &amp;&amp; left ==null))&#123; return false; &#125;else &#123; return left.val==right.val&amp;&amp;help(left.right,right.left)&amp;&amp;help(left.left,right.right); &#125; &#125; 59.按之字形顺序打印二叉树请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; int layer = 1; //s1存奇数层节点 Stack&lt;TreeNode&gt; s1 = new Stack&lt;TreeNode&gt;(); s1.push(pRoot); //s2存偶数层节点 Stack&lt;TreeNode&gt; s2 = new Stack&lt;TreeNode&gt;(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); while (!s1.empty() || !s2.empty()) &#123; if (layer%2 != 0) &#123; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); while (!s1.empty()) &#123; TreeNode node = s1.pop(); if(node != null) &#123; temp.add(node.val); System.out.print(node.val + " "); s2.push(node.left); s2.push(node.right); &#125; &#125; if (!temp.isEmpty()) &#123; list.add(temp); layer++; System.out.println(); &#125; &#125; else &#123; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); while (!s2.empty()) &#123; TreeNode node = s2.pop(); if(node != null) &#123; temp.add(node.val); System.out.print(node.val + " "); s1.push(node.right); s1.push(node.left); &#125; &#125; if (!temp.isEmpty()) &#123; list.add(temp); layer++; System.out.println(); &#125; &#125; &#125; return list; &#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-7大原则]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2001%20%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[设计模式设计模式7大原则 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础。 23种设计模式 设计模式的目的 代码的重用性（相同的代码，不用多吃编写） 可读性（编程规范，便于阅读） 可扩展性（新增功能，非常方便，可维护） 可靠性（新增功能，对原来没有影响） 使程序呈现高内聚，低耦合的特征 设计模式的七大原则1.单一职责原则​ 即一个类只负责一项职责。 注意事项和细节 降低类的复杂程度，一个类只负责一项职责。 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违背单一职责原则，只有类中方法足够少，可以在方法级别保持单一职责原则。 2.接口隔离原则一个类对另外一个类的依赖应该建立在最小的接口上 含义： 一个接口代表一个角色，不应该将不同的角色都交给一个接口，因为这样可能会形成一个臃肿的大接口； 特定语言的接口，表示接口仅仅是提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。 根据接口隔离原则，我们可明白，每个接口都应只承担一种相对独立的角色，不干不该干的事情. 3.依赖倒转原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象 依赖倒置的中心思想是面向接口编程 依赖倒转原则是基于：相对于细节的多变性，抽象的东西稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。 使用接口或抽象类的目的是制定好规范，而不涉及任何具体操作，把展示细节的任务交给他们的实现类去完成。 依赖倒置原则的注意事项和细节 低层模块尽量都要有抽象类或者接口，或者两者都有，程序稳定性更好 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。 继承时遵循里氏替换原则。 4.里氏替换原则 继承性的思考和说明： 继承在给程序带来便利的同时，也带来了弊端。比如使用继承会给程序带来入侵性，程序的可移植性降低，增加对象之间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都可能产生故障。 所有引用基类的地方必须能透明地使用其子类的对象 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。 继承实际上让两个类的耦合性增加，在适当的情况下，可以通过聚合，组合，依赖来解决问题或者添加基类来解决。 5.开闭原则开闭原则是编程中最基础、最重要的设计原则 一个软件的实体如类，模块和函数应该对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则 6.迪米特法则 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则又称“最少知道原则”，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，对外除了提高的public 方法，不会对外泄露任何信息 简单定义：只与直接朋友通信 直接朋友：每个对象都会对其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系，我们称：“成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友”。也就是说，陌生的类最好不要以局部变量的形式出现在类内部。 注意事项和细节 迪米特法则的核心是降低类之间的耦合 由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系。 7.合成复用原则原则是尽量使用合成/聚合的方式，而不是使用继承 设计原则的核心思想 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计而努力。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-建造者模式]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2007%20%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式建造者模式的四个角色 product：一个具体的产品对象。 Builder（抽象建造者）：建造一个product对象的各个部分指定的接口/抽象类。 Concrete Builder(具体建造者)：实现接口，构建和装配各个部件。 Director(指挥者)：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离了客户与对象的产生过程，二是：负责控制产品对象的生产过程。 ​ 注意事项： 客户端（使用程序）不必知道产品内部的组成细节，将产品本身鱼2产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体的建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的建造者，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体的建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合”开闭原则“ 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。 抽象工厂模式vs建造者模式 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组成。采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可，而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-原型模式]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2006%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式传统方式 的优缺点： 优点是比较好理解，简单易操作。 在创建新的对象时，总是是需要获取原始对象的属性，如果创建的对象比较复杂时，效率比较低。 总是 需要重新初始化对象，而不是动态地获取对象运行时的状态，不够灵活 解决思路 java中Object类是所有类的根类，object类提供了一个clone（）方法，该方法可以将一个Java对象复杂一份，但是需要实现clone的Java类必须要实现一个接口Clone able，该接口表示该类能够复制且具有复制的能力=》原型模式 基本介绍： 原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可以定制的对象，无需知道如何创建的细节。 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们来自己实施创建，即，对象clone() 原理结构图说明 prototype:原型类，声明一个克隆自己的接口。 Concrete Prototype:具体的原型类，实现一个克隆自己的操作。 client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）。 深拷贝基本介绍 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请储存空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象，也就是说：对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝。 深拷贝的实现方法1：重写clone方法来实现深拷贝。 深拷贝的实现方法2：通过对象序列化实现深拷贝 注意事项和细节 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率 不用重新初始化对象，而是动态地获取对象运行时的状态。 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码。 再实现深克隆的时候可能需要比较复杂的代码。 缺点：需要为每一个类配置一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背ocp原则。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2005%20%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式1.简单工厂模式1.基本介绍： 1.简单工厂模式是属于创建型模式，是工厂模式的一种，简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例，简单工厂模式是工厂模式家族中最简单的模式 2.简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为 3.在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 2.工厂方法模式1.基本介绍 定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类。 3.抽象工厂模式1.基本介绍 1.定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。 2.抽象工厂模式可以将简单工厂模式和工厂方法模式进行结合。 3.从设计层面是看，抽象工厂模式就是对简单工厂模式的改进。 4.将工厂抽象层两层，抽象工厂和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类，将单个的简单工厂变成了工厂簇，更利于代码的维护和扩展。 总结：1.工厂模式的意义： 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦，从而提高项目的扩展和维护性。 2.三种工厂模式（简单工厂模式，工厂方法模式，抽象工厂模式） 3.设计模式的依赖抽象原则。 创建对象实例时，不要直接new类，而是把这个类的动作放到一个工厂的方法中，并返回。变量不要直接持有具体类的引用。 不要让类继承具体类，而是继承抽象类或者实现interface接口 不要覆盖基类中已经实现的方法。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2004%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。 分类： 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程不安全，同步代码块） 双重检查 静态内部类 枚举 饿汉式（静态常量）12345678910class Singleton&#123; //1.构造器私有化，外部不能new private Singleton()&#123;&#125; //2.本类内部创建对象实例 private final static Singletion instance = new Singleton(); //3.提供一个公有的静态方法，返回实例对象 public static Singletion getInstance()&#123; return instance; &#125;&#125; 优缺点 写法简单，就是类加载的时候完成实例化，避免了线程同步。 缺点：在类加载的时候完成完成实例化，没有达到懒加载效果，如果从开始至终从未使用过这个实例，则会造成内存浪费。 结论：这种单例模式可用，可能造成内存浪费 饿汉式（静态代码块）12345678910111213class Singleton&#123; //1.构造器私有化，外部不能new private Singleton()&#123;&#125; //2.本类内部创建对象 private static Singletion instance; static&#123;//静态代码块中，创建单例对象 instance = new Singleton(); &#125; //3.提供一个公有的静态方法，返回实例对象 public static Singletion getInstance()&#123; return instance; &#125;&#125; 懒汉式（线程不安全）123456789101112class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; //提供一个静态的公用方法，当使用到该方法时，才去创建instance public static Singleton getInstance()&#123; if(instance == null )&#123; instance = new Singletion(); &#125; return instance; &#125;&#125; 优缺点 1.起到懒加载的效果，但是不能在单线程下使用。 2.如果在多线程下，一个线程进入了if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会多产生一个实例。 结论：在实际开发中，不能使用这种方式。 懒汉式（线程安全，同步方法）123456789101112class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; //提供一个静态的公用方法，加入同步处理的代码，解决线程安全的问题，才去创建instance public static synchronized Singleton getInstance()&#123; if(instance == null )&#123; instance = new Singletion(); &#125; return instance; &#125;&#125; 优缺点 解决了线程不安全的问题 效率太低了，每个线程在想得到类的实例的时候，执行getInstance()方法都要进行同步，而且其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了，方法进行同步效率太低。 结论：在实际开发中，不推荐使用这种方法。 懒汉式（线程不安全，同步代码块）12345678910111213141516class Singleton&#123; //1.构造器私有化，外部不能new private Singleton()&#123;&#125; //2.本类内部创建对象 private static Singletion instance; //3.提供一个公有的静态方法，返回实例对象 public static Singletion getInstance()&#123; if(singleton == null)&#123; synchronized(Singletion.class)&#123; singleton = new Singleton(); &#125; &#125; return instance; &#125;&#125; 优缺点 1.这种同步方法并不能起到线程同步的作用，假如一个if(singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多一个实例。 结论：在实际开发中，不能使用这种方式。 双重检查（推荐）1234567891011121314151617class Singleton&#123; private Singleton()&#123;&#125; private static volatile Singletion instance; public static Singletion getInstance()&#123; if(singleton == null)&#123; synchronized(Singletion.class)&#123; if(singletion == null)&#123; singleton = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优缺点： Double-Check概念是多线程开发中常使用到的，我们进行两次if检查，这样就可以保证线程安全。 实例化代码只用执行一次，后面再次进行访问，直接返回。 线程安全，延迟加载，效率高 结论：在实际开发中，推荐使用这种单例设计模式。 静态内部类1234567891011class Singleton&#123; private Singleton()&#123;&#125; //写一个静态内部类，该类中一个静态属性Singleton private static class SingletonInstance&#123; private static final Singleton instance = new Singleton(); &#125; //提供一个静态的公有方法，直接返回 public static Singleton getInstance()&#123; return SingletonInstance.instance; &#125;&#125; 优缺点 采用了类加载的机制来保证初始化实例时只要一个线程。 静态内部类方法在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用。 类的静态属性只会在第一次加载类的时候被初始化。可以保证线程安全。 总结：避免了线程不安全，利用静态内部类的特点实现延迟加载，效率高。 枚举123enum Singleton&#123; instance;&#125; 优缺点 借助jdk1.5中添加来实现单例化，不仅可以避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 单例模式在jdK中的应用：java.lang.Runtime使用懒汉式加载。 单例模式注意事项和细节说明：1.单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 2.当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new 3.单例模式使用的场景，需要频繁的进行创建和销毁的对象，创建对像时耗时过多或耗费资源过多但是又经常用到的对象、工具类对象、频繁访问数据库或文件的对象。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-概述与分类]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2003%20%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[设计模式–概述与分类介绍设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，设计模式不是代码，而是某类问题的通用解决方案，设计模式代表最佳的实践 设计模式的本质提高软件的维护性，通用性和扩展性，并降低软件的复杂度。 设计模式类型1.创建型模式：单例模式，抽象工厂模式，原型模型，建造者模式，工厂模式。 2.结构型模式：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。 3.行为型模式：模版方法模式，命令模式，访问者模式，迭代器模式，观察者模式，中介模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-UML类图]]></title>
    <url>%2F2020%2F01%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2002%20UML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML类图基本介绍UML—统一建模语言。是一种用于软件系统分析和设计的语言工具，它有用于帮助软件开发人员进行思考和记录思路的结果 UML图画UML图与写文章差不多，都是把自己的思路描述给别人看，关键在于思想和条理 分类： 用例图 静态结构图：类图，对象图，包图，组件图，部署图 动态行为图：交互图（时序图与协作图），状态图、活动图 说明： 类图是描述类与类之间的关系的，是UML图 各种关系的强弱顺序： 泛化***=*** 实现***&gt;*** 组合***&gt;*** 聚合***&gt;*** 关联***&gt;*** 依赖 依赖关系只要是在类中用到了对方，那么他们之间就存在依赖关系，如果没有对方，连编译都通过不了 总结 类中用到了对方 如果是类的成员属性 如果是方法的返回类型 是方法接收的参数类型 方法中使用到 泛化关系泛化关系实际上就是继承关系，他是依赖关系中的特例 如果A类继承了B类，那A与B存在泛化关系 实现关系 实现关系就是实现某个接口，他是依赖关系中的特例 关联关系关联关系实际上就是类与类之间的联系，他是依赖关系的特例 关联关系具有导航性：即双向关系或单向关系 聚合关系聚会关系表示的是整体和部分的关系，整体与部分可以分开，聚会关系是关联关系的特例 具有导航性和多重性 组合关系两个类之间是共生关系的，整体与部分不可分开 如果程序中Person实体中定义了对IDCard进行级联删除，即删除Person时，连同IDCard一起删除，那么IDCard和Person就是组合了。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2019%2F12%2F12%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式基本介绍 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，Hexo]]></title>
    <url>%2F2019%2F07%2F08%2F%E4%BD%A0%E5%A5%BD%EF%BC%8CHexo%2F</url>
    <content type="text"><![CDATA[我的第一篇文章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
